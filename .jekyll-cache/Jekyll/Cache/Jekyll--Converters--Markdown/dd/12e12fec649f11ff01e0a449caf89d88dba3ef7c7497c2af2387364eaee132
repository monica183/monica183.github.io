I"	<h5 id="this表示当前执行的对象">this：表示当前执行的对象</h5>

<p>this.属性名来使用属性、this.方法名、this(实参)实现构造方法</p>

<p>注意：this不能在static方法或static代码块中使用，this调用构造方法时，必须在第一行</p>

<p>super：表示父类对象
​ super.属性名来使用属性、super.方法名、super(实参)实现构造方法</p>

<p>注意：super调用构造方法时，必须在第一行<!--more--></p>

<h5 id="static静态">static：静态</h5>

<p>static修饰的内容是在虚拟机加载时就已经执行了。</p>

<p>属性：可以使用类名.属性名直接调用，也可以通过实例.属性名调用。该属性变为共享属性，只有一个内存地址。</p>

<p>方法：可以使用类名.方法名直接调用，也可以通过实例.方法名调用。</p>

<p>内部类：外部类.内部类 实例名 = new 外部类.内部类()</p>

<h5 id="abstract抽象">abstract：抽象</h5>

<p>抽象：意思是只知道一大概行为和属性</p>

<p>修饰类：抽象类，不能被实例化，即不能创建对象。但可以有构造方法。其构造方法就是让子类来调用的。抽象类可以有抽象方法也可以普通方法。常用在模板设计模式</p>

<p>修饰方法：抽象方法，不需要实现，抽象方法只能存在于抽象类和接口中，抽象方法要求子类必须实现，即重写</p>

<p>格式：权限修饰符 abstract 返回值类型 方法名();</p>

<p>注意：abstract不可以与static和final一起使用</p>

<h5 id="final最终">final：最终</h5>

<p>属性：修饰的属性的值将不可改变，也称为常量</p>

<p>方法：修饰的方法不可以被子类重写</p>

<p>类：修饰的类叫做太监类，即没有子类，表示不可被继承。例如：String类</p>

<h5 id="interface-接口">interface: 接口</h5>

<p>与抽象类相似，且比抽象类更加抽象。</p>

<p>格式：权限修饰符 interface 类名 {</p>

<p>只有常量和public abstract修饰的方法</p>

<p>但是在JDK8之后，包括8，可以使用default关键字来实现接口中方法</p>

<p>}</p>

<p>使用，接口只能通过实现(implements)，一个类可以实现多个接口，使用逗号分隔</p>

<p>格式：权限修饰符 class 类名 implements 接口1, 接口2， … {}</p>

<p>注意：抽象类可以继承也可实现接口，接口与接口之间也可以继承</p>
:ET